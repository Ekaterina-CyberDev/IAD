import math

# Функция вычисления нормального распределения
def f_norm(x, mu=0, sigma=1):
    z = (x - mu) / sigma  # Стандартизация значения
    if z < -8: return 0  # Левая граница распределения
    if z > 8: return 1   # Правая граница распределения
    s = 0  # Инициализация суммы ряда
    t = z  # Первый член ряда
    for i in range(1, 50):  # Разложение в ряд Тейлора
        s += t  # Добавление члена ряда к сумме
        t *= -z*z/(2*i+1)  # Вычисление следующего члена ряда
    return 0.5 + s/math.sqrt(2*math.pi)  # Нормальное распределение

# Функция обратного нормального распределения
def inv_f_norm(p, mu=0, sigma=1):
    if p <= 0: return -8*sigma + mu  # Минимальное значение
    if p >= 1: return 8*sigma + mu   # Максимальное значение
    
    low, high = -8, 8  # Границы поиска
    for _ in range(50):  # Бинарный поиск
        mid = (low + high) / 2  # Середина интервала
        if f_norm(mid) < p:  # Сравнение с вероятностью
            low = mid  # Сдвиг левой границы
        else:
            high = mid  # Сдвиг правой границы
    return low * sigma + mu  # Возврат результата

# Исходные данные
data = [1.7, -5.4, -4.0, -5.9, -1.6, 0.0, 0.6, 2.1, 0.1, -4.9, -3.5, 
        5.9, 8.5, 9.9, 13.3, 11.1, 14.4, 16.2]
t = list(range(len(data)))  # Временные точки

# Подготовка данных для экспоненциальной аппроксимации
positive_data = [x + 10 for x in data]  # Сдвиг в положительную область
y = [math.log(x) for x in positive_data]  # Логарифмирование данных

# Вычисление сумм для МНК
sum_t = sum(t)  # Сумма временных точек
sum_y = sum(y)  # Сумма логарифмов
sum_t2 = sum(ti*ti for ti in t)  # Сумма квадратов времени
sum_yt = sum(ti*yi for ti, yi in zip(t, y))  # Сумма произведений
n = len(t)  # Количество точек

# Вычисление параметров экспоненты
b = (sum_yt*n - sum_t*sum_y) / (sum_t2*n - sum_t*sum_t)  # Коэффициент b
a = (sum_y - b*sum_t) / n  # Коэффициент a
A = math.exp(a)  # Преобразование коэффициента A

# Расчет предсказанных значений
predicted = [A * math.exp(b*ti) - 10 for ti in t]  # Обратное преобразование

# Анализ остатков (разница между реальными и предсказанными значениями)
residuals = [data[i] - predicted[i] for i in range(n)]  # Вычисление остатков
mu_res = sum(residuals) / n  # Среднее остатков
sigma_res = math.sqrt(sum((r - mu_res)**2 for r in residuals) / (n-1))  # Стандартное отклонение

# Проверка нормальности распределения остатков
max_dev = max(abs(r - mu_res) for r in residuals)  # Максимальное отклонение
p_value = 2 * (1 - f_norm(max_dev/sigma_res))  # p-значение

print("Параметры модели: A =", round(A, 2), "b =", round(b, 2))
print("Среднее остатков:", round(mu_res, 2))
print("Стд. отклонение остатков:", round(sigma_res, 2))
print("Наибольшее отклонение:", round(max_dev, 2))
print("p-значение:", round(p_value, 3))

# Проверка статистической гипотезы
if p_value > 0.05:  # Сравнение с уровнем значимости 5%
    print("Гипотеза принимается: последовательность аппроксимируется экспоненциальной функцией")
else:
    print("Гипотеза отвергается: последовательность НЕ аппроксимируется экспоненциальной функцией")