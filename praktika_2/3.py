import math

def normal_cdf(x, mu, sigma):
    return 0.5 * (1 + math.erf((x - mu) / (sigma * math.sqrt(2)))) # Формула с использованием функции ошибок (error function)

def calculate_power(n, p0, p_alt, alpha=0.05):
    """Расчет статистической мощности проверки гипотезы"""
    
    # Вычисление параметров при нулевой гипотезе (H0: p = p0)
    mu0 = n * p0  # Математическое ожидание числа успехов при H0
    sigma0 = math.sqrt(n * p0 * (1 - p0))  # Стандартное отклонение при H0
    
    # Определение критических значений для двустороннего теста
    z_critical = 1.96  # Z-значение для уровня значимости 5% (alpha = 0.05)
    lower_bound = mu0 - z_critical * sigma0  # Нижняя граница области принятия H0
    upper_bound = mu0 + z_critical * sigma0  # Верхняя граница области принятия H0
    
    # Вычисление параметров при альтернативной гипотезе (H1: p = p_alt)
    mu_alt = n * p_alt  # Математическое ожидание при H1
    sigma_alt = math.sqrt(n * p_alt * (1 - p_alt))  # Стандартное отклонение при H1
    
    # Вероятность совершить ошибку 2-го рода (beta) = вероятность попасть в область принятия H0, когда верна H1
    beta = (normal_cdf(upper_bound, mu_alt, sigma_alt) - 
            normal_cdf(lower_bound, mu_alt, sigma_alt))
    
    # Мощность теста = 1 - beta (вероятность правильно отклонить H0)
    power = 1 - beta
    
    return power, lower_bound, upper_bound

# Параметры из примера с биатлонистом Сидоровым
n = 1000 # количество выстрелов (объем выборки)
p0 = 0.1 # нулевая гипотеза: вероятность промаха = 10%
p_alt = 0.13 # альтернативная гипотеза: вероятность промаха = 13%

# Вычисление мощности проверки и границ принятия гипотезы
power, lower, upper = calculate_power(n, p0, p_alt)

print(f"Мощность проверки: {power:.3f} ({power*100:.1f}%)")
print(f"Область принятия H0: [{lower:.1f}, {upper:.1f}] промахов")