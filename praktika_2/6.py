import math

# Функция нормального распределения (кумулятивная)
def f_norm(x, mu=0, sigma=1):
    z = (x - mu) / sigma # Стандартизация переменной (приведение к стандартному нормальному распределению)
    if z < -8: return 0 # Обработка крайних левых значений (z < -8) - вероятность практически 0
    if z > 8: return 1 # Обработка крайних правых значений (z > 8) - вероятность практически 1
    s = 0 # Инициализация суммы ряда Тейлора
    t = z # Первый член ряда Тейлора
    for i in range(1, 50): # Разложение в ряд Тейлора для интеграла нормального распределения
        s += t # Добавление текущего члена ряда к сумме
        t *= -z*z/(2*i+1) # Вычисление следующего члена ряда: t_{n+1} = t_n * (-z²/(2n+1))
    return 0.5 + s/math.sqrt(2*math.pi) # Возврат нормализованного результата: 0.5 + сумма_ряда/√(2π)

# Данные из задачи 4 (экспоненциальная модель - лучшая)
mu_exp = -0.13    # среднее остатков
sigma_exp = 2.99  # стандартное отклонение остатков

# Данные из задачи 5 (полиномиальная модель - худшая)
mu_poly = 0.0     # среднее отклонений (округлено до 0)
sigma_poly = 3.0  # стандартное отклонение отклонений (округлено до 3.0)

# Границы доверительного интервала для лучшей модели (95% уровень значимости)
alpha = 0.05
z_low = -1.96  # квантиль нормального распределения для 2.5%
z_high = 1.96  # квантиль нормального распределения для 97.5%

# Расчет нижней границы 95% доверительного интервала для остатков лучшей модели
# mu_exp - среднее значение остатков экспоненциальной модели
# z_low = -1.96 - нижний квантиль нормального распределения для 95% доверительного интервала
# sigma_exp - стандартное отклонение остатков экспоненциальной модели
low_bound = mu_exp + z_low * sigma_exp

# Расчет верхней границы 95% доверительного интервала для остатков лучшей модели
# z_high = 1.96 - верхний квантиль нормального распределения для 95% доверительного интервала
high_bound = mu_exp + z_high * sigma_exp

print(f"Доверительный интервал для лучшей модели: [{low_bound:.2f}, {high_bound:.2f}]")

# Расчет мощности проверки (вероятность не совершить ошибку 2-го рода)
# Вероятность, что худшая модель попадет в доверительный интервал лучшей
p_low = f_norm(low_bound, mu_poly, sigma_poly)
p_high = f_norm(high_bound, mu_poly, sigma_poly)
probability_type_2_error = p_high - p_low

# Мощность проверки = 1 - вероятность ошибки 2-го рода
power = 1 - probability_type_2_error

print(f"Вероятность ошибки 2-го рода: {probability_type_2_error:.3f}")
print(f"Мощность проверки: {power:.3f} ({power*100:.1f}%)")

# Интерпретация результата
if power > 0.8:
    print("Высокая мощность проверки (>80%) - хорошая способность различать модели")
elif power > 0.5:
    print("Умеренная мощность проверки (50-80%)")
else:
    print("Низкая мощность проверки (<50%) - плохая способность различать модели")