import math

# Функция решения системы линейных уравнений методом Гаусса
def gauss_solve(A, b):
    n = len(b)  # Определяем размерность системы
    # Прямой ход метода Гаусса
    for i in range(n):
        # Поиск строки с максимальным элементом в текущем столбце
        max_row = i
        for j in range(i+1, n):
            if abs(A[j][i]) > abs(A[max_row][i]):
                max_row = j
        # Перестановка строк для устойчивости
        A[i], A[max_row] = A[max_row], A[i]
        b[i], b[max_row] = b[max_row], b[i]
        
        # Исключение переменных
        for j in range(i+1, n):
            factor = A[j][i] / A[i][i]  # Вычисление множителя
            for k in range(i, n):
                A[j][k] -= factor * A[i][k]  # Обновление матрицы
            b[j] -= factor * b[i]  # Обновление правой части
    
    # Обратный ход метода Гаусса
    x = [0] * n  # Инициализация вектора решений
    for i in range(n-1, -1, -1):  # Идем от последнего уравнения к первому
        x[i] = b[i]  # Начинаем с правой части
        for j in range(i+1, n):
            x[i] -= A[i][j] * x[j]  # Вычитаем уже найденные решения
        x[i] /= A[i][i]  # Делим на коэффициент при переменной
    return x  # Возвращаем решение

# Функция аппроксимации полиномом заданной степени
def approx_poly(x, t, r):
    n = len(x)  # Количество точек данных
    M = [[0]*(r+1) for _ in range(r+1)]  # Матрица системы нормальных уравнений
    b_vec = [0]*(r+1)  # Вектор правой части системы
    
    # Заполнение матрицы и вектора для метода наименьших квадратов
    for l in range(r+1):
        for q in range(r+1):
            # Сумма степеней времени для матрицы
            M[l][q] = sum(ti**(l+q) for ti in t)
        # Сумма произведений данных на степени времени для правой части
        b_vec[l] = sum(xi * ti**l for xi, ti in zip(x, t))
    
    return gauss_solve(M, b_vec)  # Решение системы и возврат коэффициентов

# Функция нормального распределения (кумулятивная)
def f_norm(x, mu=0, sigma=1):
    z = (x - mu) / sigma  # Стандартизация переменной
    return 0.5 * (1 + math.erf(z / math.sqrt(2)))  # Использование функции ошибок

# Функция вычисления p-значения (двустороннего)
def p_value(x, mu, sigma):
    if x >= mu:
        return 2 * (1 - f_norm(x, mu, sigma))  # Правый хвост
    else:
        return 2 * f_norm(x, mu, sigma)  # Левый хвост

# Основная часть программы
x = [1.7, -5.4, -4.0, -5.9, -1.6, 0.0, 0.6, 2.1, 0.1, -4.9, -3.5, 
     5.9, 8.5, 9.9, 13.3, 11.1, 14.4, 16.2] # Исходные данные для аппроксимации
t = list(range(len(x)))  # Временные точки (0, 1, 2, ...)

# Аппроксимация полиномом 4-го порядка
coeffs = approx_poly(x, t, 4)  # Получение коэффициентов полинома

# Вычисление предсказанных значений по найденному полиному
x_pred = []
for ti in t:
    pred = sum(c * ti**i for i, c in enumerate(coeffs))  # Вычисление значения полинома
    x_pred.append(pred)  # Добавление в список предсказаний

# Вычисление отклонений (ошибок) между реальными и предсказанными значениями
errors = [xi - pred for xi, pred in zip(x, x_pred)]

# Статистический анализ отклонений
mu_err = sum(errors) / len(errors)  # Среднее значение отклонений
sigma_err = math.sqrt(sum((e - mu_err)**2 for e in errors) / len(errors))  # Стандартное отклонение

# Находим максимальное абсолютное отклонение от среднего
max_error = max(abs(e - mu_err) for e in errors)
# Вычисляем p-значение для максимального отклонения
max_p_value = p_value(max_error, 0, sigma_err)

print("Коэффициенты полинома:", [round(c, 3) for c in coeffs])
print("Среднее отклонение:", round(mu_err, 3))
print("Стандартное отклонение:", round(sigma_err, 3))
print("Максимальное отклонение:", round(max_error, 3))
print("p-значение для максимального отклонения:", round(max_p_value, 3))

# Проверка статистической гипотезы на уровне значимости 5%
if max_p_value > 0.05:
    print("Гипотеза принимается (p > 0.05)")  # Отклонения нормально распределены
else:
    print("Гипотеза отвергается (p ≤ 0.05)")  # Отклонения не нормально распределены